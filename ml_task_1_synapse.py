# -*- coding: utf-8 -*-
"""ML TASK 1 SYNAPSE

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mJTPJApJzsaCVsbjW4h0H6rmCE9OjBOM
"""

#Task 1.1

superheroes = ['IRON_MAN', 'BLACK_WIDOW', 'CAPTAIN_AMERICA', 'THOR', 'HULK', 'SCARLET_WITCH', 'SPIDER_MAN']
# Creating empty lists which are required
indices = []
decoded_names = []

# Filling indices and decoded_names using enumerate() and append()
for index, name in enumerate(superheroes):
    indices.append(index)
    decoded_names.append(name.lower().replace('_', ' '))

# Creating a lambda function (Temporary) to return the length of strings passed in it
get_length = lambda seq: len(seq)

# Using map() to apply the lambda function to decoded_names and create name_lengths list
name_lengths = list(map(get_length, decoded_names))

# Sort the indices list based on the name_lengths list
indices.sort(key=lambda i:name_lengths[i])

# Displaying the list with names in "Title" case
print("Phase 5 kickoff list:")
for count, index in enumerate(indices, start=1):
    print(f"{count}. {decoded_names[index].title()}")

#TASK 1.2
def convert_binary_to_decimal(binary_list):
    decimal_list = [int(binary, 2) for binary in binary_list]
    return decimal_list

def minimize_difference(decimal_list):
    decimal_list.sort()
    while len(decimal_list) > 2:
        # Finding the two smallest elements

        smallest1 = decimal_list.pop(0)
        smallest2 = decimal_list.pop(0)

        # Calculating the sum and add it back to the list
        new_element = smallest1 + smallest2
        decimal_list.append(new_element)

    result_difference = abs(decimal_list[0] - decimal_list[1])
    return decimal_list, result_difference

# Input binary numbers as strings separated by spaces
binary_input = input("Enter the list of binary numbers separated by spaces: ")
binary_list = binary_input.split()

decimal_list = convert_binary_to_decimal(binary_list)
final_list, final_difference = minimize_difference(decimal_list)

print("Final list:", final_list)
print("Final difference:", final_difference)

#Task 1.3
def explode_chains_list(list_of_encoded_lists):
    def explode_chains(encoded_list):
        while True:
            found_chain = False
            new_list = []
            i = 0

            while i < len(encoded_list):
                if i + 2 < len(encoded_list) and encoded_list[i] + 1 == encoded_list[i + 1] and encoded_list[i] + 2 == encoded_list[i + 2]:
                    found_chain = True
                    i += 3  # Skip the three numbers in the sequence
                else:
                    new_list.append(encoded_list[i])
                    i += 1

            if not found_chain:
                break

            encoded_list = new_list

        return encoded_list

    result_list = []
    for encoded_list in list_of_encoded_lists:
        result_list.append(explode_chains(encoded_list))

    return result_list

# User input for the list of encoded lists
num_of_lists = int(input("Enter the number of encoded lists: "))
list_of_encoded_lists = []

for _ in range(num_of_lists):
    encoded_list = [int(x) for x in input("Enter the encoded list separated by spaces: ").split()]
    list_of_encoded_lists.append(encoded_list)

result = explode_chains_list(list_of_encoded_lists)
print("Result:", result)

#Task 1.4
import random

class ChessPlayer:
    def __init__(self, name, age, ELO, tenacity, isBoring):
        self.name = name
        self.age = age
        self.ELO = ELO
        self.tenacity = tenacity
        self.isBoring = isBoring
        self.tournament_score = 0

    def simulate_match(self, opponent):
        elo_diff = abs(self.ELO - opponent.ELO)

        if elo_diff > 100:
            if self.ELO > opponent.ELO:
                self.tournament_score += 1
            else:
                opponent.tournament_score += 1

        elif self.isBoring or opponent.isBoring:
            if elo_diff <= 100:
                self.tournament_score += 0.5
                opponent.tournament_score += 0.5

        elif 100 >= elo_diff >= 50:
            random_factor = random.randint(1, 10)
            lower_elo_product = random_factor * (opponent.tenacity if opponent.ELO < self.ELO else self.tenacity)

            if lower_elo_product > (self.ELO if self.ELO > opponent.ELO else opponent.ELO):
                (self.tournament_score+1) if opponent.ELO < self.ELO else (opponent.tournament_score+1)

        else:
            if self.tenacity > opponent.tenacity:
                self.tournament_score += 1
            else:
                opponent.tournament_score += 1


def simulate_tournament(players):
    num_players = len(players)
    for i in range(num_players):
        for j in range(i + 1, num_players):
            player1 = players[i]
            player2 = players[j]
            player1.simulate_match(player2)
            player2.simulate_match(player1)

def print_tournament_results(players):
    print("Tournament Results:")
    print("{:<25} {:<10}".format("Player", "Score"))
    print("-" * 35)
    for player in players:
        print("{:<25} {:<10}".format(player.name, player.tournament_score))

# Create ChessPlayer instances
players = [
    ChessPlayer("Courage the Cowardly Dog", 25, 1000.39, 1000, False),
    ChessPlayer("Princess Peach", 23, 945.65, 50, True),
    ChessPlayer("Walter White", 50, 1650.73, 750, False),
    ChessPlayer("Rory Gilmore", 16, 1700.87, 500, False),
    ChessPlayer("Anthony Fantano", 37, 1400.45, 400, True),
    ChessPlayer("Beth Harmon", 20, 2500.34, 150, False)
]

# Simulate the tournament
simulate_tournament(players)

# Print tournament results
print_tournament_results(players)